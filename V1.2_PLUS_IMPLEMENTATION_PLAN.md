# é›¶ç½‘ç»œç©ºé—´ V1.2+ å®ç°è®¡åˆ’

> åŸºäºäº§å“å®šä½ä¹¦å®Œæˆå‰©ä½™çš„ V1.2 å¢å¼ºåŠŸèƒ½å’Œå…³é”®ç¼ºå¤±åŠŸèƒ½

**è®¡åˆ’ç‰ˆæœ¬**: V1.2+  
**è®¡åˆ’æ—¶é—´**: 3-4 å‘¨  
**ç›®æ ‡**: å®Œæˆäº§å“å®šä½ä¹¦ V1.2 æ‰¿è¯ºçš„æ‰€æœ‰åŠŸèƒ½

---

## ğŸ“Š å®ç°ä¼˜å…ˆçº§æ¦‚è§ˆ

| ä¼˜å…ˆçº§ | åŠŸèƒ½ | å·¥ä½œé‡ | å®Œæˆæ—¶é—´ |
|--------|------|--------|---------|
| **P0** | æ·±è‰²æ¨¡å¼ç‹¬ç«‹åˆ‡æ¢ | 1-2å¤© | Week 1 |
| **P0** | ç”Ÿç‰©è¯†åˆ«è®¤è¯ (Face ID/Touch ID) | 2-3å¤© | Week 1 |
| **P0** | æ— ç½‘ç»œéªŒè¯ç•Œé¢ | 2å¤© | Week 1 |
| **P1** | éšè—ç©ºé—´ | 3-5å¤© | Week 2 |
| **P1** | ä¼ªè£…æ¨¡å¼ | 4-6å¤© | Week 3-4 |
| **P2** | æ‰¹é‡å¯¼å‡º | 2-3å¤© | Week 4 |
| **P2** | æ€§èƒ½ä¼˜åŒ– | æŒç»­ | Week 4 |

---

## Week 1: P0 åŠŸèƒ½å®ç° (å¿«é€Ÿè§æ•ˆ)

### ä»»åŠ¡ 1.1: æ·±è‰²æ¨¡å¼ç‹¬ç«‹åˆ‡æ¢ â­ P0

**ç›®æ ‡**: åº”ç”¨å†…ç‹¬ç«‹æ·±è‰²/æµ…è‰²åˆ‡æ¢,ä¸è·Ÿéšç³»ç»Ÿ

**å·¥ä½œé‡**: 1-2 å¤©

#### å®ç°æ­¥éª¤

**Step 1: æ‰©å±• AppSettings æ¨¡å‹** (30åˆ†é’Ÿ)

```swift
// File: ZeroNet-Space/Models/AppSettings.swift

/// åº”ç”¨é¢œè‰²æ–¹æ¡ˆ
enum AppColorScheme: String, CaseIterable, Identifiable {
    case system = "è·Ÿéšç³»ç»Ÿ"
    case light = "æµ…è‰²æ¨¡å¼"
    case dark = "æ·±è‰²æ¨¡å¼"
    
    var id: String { rawValue }
    
    var colorScheme: ColorScheme? {
        switch self {
        case .system: return nil
        case .light: return .light
        case .dark: return .dark
        }
    }
    
    var iconName: String {
        switch self {
        case .system: return "circle.lefthalf.filled"
        case .light: return "sun.max.fill"
        case .dark: return "moon.fill"
        }
    }
}

// åœ¨ AppSettings ç±»ä¸­æ·»åŠ :
class AppSettings: ObservableObject {
    // ... ç°æœ‰ä»£ç  ...
    
    /// é¢œè‰²æ–¹æ¡ˆåå¥½
    @Published var colorSchemePreference: AppColorScheme {
        didSet {
            defaults.set(colorSchemePreference.rawValue, 
                        forKey: AppConstants.UserDefaultsKeys.colorScheme)
            print("ğŸ“ é¢œè‰²æ–¹æ¡ˆå·²æ›´æ–°: \(colorSchemePreference.rawValue)")
        }
    }
    
    private init() {
        // ... ç°æœ‰åˆå§‹åŒ–ä»£ç  ...
        
        // è¯»å–é¢œè‰²æ–¹æ¡ˆè®¾ç½®
        if let savedScheme = defaults.string(forKey: AppConstants.UserDefaultsKeys.colorScheme),
           let scheme = AppColorScheme(rawValue: savedScheme) {
            self.colorSchemePreference = scheme
        } else {
            self.colorSchemePreference = .system  // é»˜è®¤è·Ÿéšç³»ç»Ÿ
        }
    }
}
```

**Step 2: æ·»åŠ  UserDefaults Key** (5åˆ†é’Ÿ)

```swift
// File: ZeroNet-Space/App/AppConstants.swift

struct AppConstants {
    struct UserDefaultsKeys {
        // ... ç°æœ‰ keys ...
        static let colorScheme = "colorScheme"  // æ–°å¢
    }
}
```

**Step 3: åº”ç”¨é¢œè‰²æ–¹æ¡ˆåˆ°æ ¹è§†å›¾** (15åˆ†é’Ÿ)

```swift
// File: ZeroNet-Space/ContentView.swift

struct ContentView: View {
    @EnvironmentObject var authViewModel: AuthenticationViewModel
    @StateObject private var settings = AppSettings.shared  // æ–°å¢
    
    var body: some View {
        Group {
            if authViewModel.isAuthenticated {
                MainTabView()
                    .environmentObject(authViewModel)
            } else if authViewModel.hasPassword {
                LoginView()
                    .environmentObject(authViewModel)
            } else {
                SetupPasswordView()
                    .environmentObject(authViewModel)
            }
        }
        .preferredColorScheme(settings.colorSchemePreference.colorScheme)  // æ–°å¢
    }
}
```

**Step 4: è®¾ç½®ç•Œé¢æ·»åŠ é€‰é¡¹** (1å°æ—¶)

```swift
// File: ZeroNet-Space/Views/Settings/SettingsView.swift

struct SettingsView: View {
    @StateObject private var settings = AppSettings.shared
    
    var body: some View {
        NavigationStack {
            List {
                // æ–°å¢: å¤–è§‚è®¾ç½®åŒºåŸŸ
                appearanceSection
                
                // ... ç°æœ‰åŒºåŸŸ ...
            }
            .navigationTitle("è®¾ç½®")
        }
    }
    
    // MARK: - Appearance Section (æ–°å¢)
    
    private var appearanceSection: some View {
        Section {
            Picker("ä¸»é¢˜æ¨¡å¼", selection: $settings.colorSchemePreference) {
                ForEach(AppColorScheme.allCases) { scheme in
                    Label(scheme.rawValue, systemImage: scheme.iconName)
                        .tag(scheme)
                }
            }
            .pickerStyle(.menu)
            
        } header: {
            Label("å¤–è§‚", systemImage: "paintpalette")
        } footer: {
            Text("é€‰æ‹©åº”ç”¨çš„é¢œè‰²ä¸»é¢˜")
        }
    }
}
```

**æµ‹è¯•æ¸…å•**:
- [ ] åˆ‡æ¢åˆ°æ·±è‰²æ¨¡å¼ - æ•´ä¸ªåº”ç”¨å˜ä¸ºæ·±è‰²
- [ ] åˆ‡æ¢åˆ°æµ…è‰²æ¨¡å¼ - æ•´ä¸ªåº”ç”¨å˜ä¸ºæµ…è‰²
- [ ] é€‰æ‹©è·Ÿéšç³»ç»Ÿ - éšç³»ç»Ÿè®¾ç½®å˜åŒ–
- [ ] è®¾ç½®æŒä¹…åŒ– - é‡å¯åº”ç”¨ä¿æŒè®¾ç½®

---

### ä»»åŠ¡ 1.2: ç”Ÿç‰©è¯†åˆ«è®¤è¯ (Face ID / Touch ID) â­ P0

**ç›®æ ‡**: æ”¯æŒ Face ID / Touch ID å¿«é€Ÿè§£é”

**å·¥ä½œé‡**: 2-3 å¤©

#### å®ç°æ­¥éª¤

**Step 1: æ·»åŠ æƒé™æè¿°** (5åˆ†é’Ÿ)

```xml
<!-- File: Info.plist -->
<key>NSFaceIDUsageDescription</key>
<string>ä½¿ç”¨é¢å®¹IDå¿«é€Ÿè§£é”ç§å¯†ç©ºé—´ï¼Œä¿æŠ¤æ‚¨çš„éšç§å®‰å…¨</string>
```

**Step 2: åˆ›å»ºç”Ÿç‰©è¯†åˆ«æœåŠ¡** (2å°æ—¶)

```swift
// File: ZeroNet-Space/Services/BiometricAuthService.swift

import LocalAuthentication
import Foundation

/// ç”Ÿç‰©è¯†åˆ«è®¤è¯æœåŠ¡
class BiometricAuthService {
    
    // MARK: - Singleton
    
    static let shared = BiometricAuthService()
    private init() {}
    
    // MARK: - Properties
    
    /// ç”Ÿç‰©è¯†åˆ«ç±»å‹
    enum BiometricType {
        case none       // ä¸æ”¯æŒ
        case touchID    // Touch ID
        case faceID     // Face ID
    }
    
    // MARK: - Public Methods
    
    /// è·å–è®¾å¤‡æ”¯æŒçš„ç”Ÿç‰©è¯†åˆ«ç±»å‹
    func biometricType() -> BiometricType {
        let context = LAContext()
        var error: NSError?
        
        guard context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) else {
            return .none
        }
        
        if #available(iOS 11.0, *) {
            switch context.biometryType {
            case .none:
                return .none
            case .touchID:
                return .touchID
            case .faceID:
                return .faceID
            @unknown default:
                return .none
            }
        } else {
            return .touchID  // iOS 11ä»¥ä¸‹é»˜è®¤Touch ID
        }
    }
    
    /// æ£€æŸ¥è®¾å¤‡æ˜¯å¦æ”¯æŒç”Ÿç‰©è¯†åˆ«
    var isBiometricAvailable: Bool {
        return biometricType() != .none
    }
    
    /// ç”Ÿç‰©è¯†åˆ«è®¤è¯
    /// - Returns: è®¤è¯æ˜¯å¦æˆåŠŸ
    func authenticate() async -> Bool {
        let context = LAContext()
        context.localizedCancelTitle = "ä½¿ç”¨å¯†ç "
        
        // è·å–æœ¬åœ°åŒ–æç¤ºæ–‡æœ¬
        let reason = getLocalizedReason()
        
        do {
            let success = try await context.evaluatePolicy(
                .deviceOwnerAuthenticationWithBiometrics,
                localizedReason: reason
            )
            
            if success {
                print("âœ… ç”Ÿç‰©è¯†åˆ«è®¤è¯æˆåŠŸ")
            }
            return success
            
        } catch let error as LAError {
            print("âŒ ç”Ÿç‰©è¯†åˆ«è®¤è¯å¤±è´¥: \(error.localizedDescription)")
            handleBiometricError(error)
            return false
            
        } catch {
            print("âŒ æœªçŸ¥é”™è¯¯: \(error.localizedDescription)")
            return false
        }
    }
    
    // MARK: - Private Methods
    
    /// è·å–æœ¬åœ°åŒ–æç¤ºæ–‡æœ¬
    private func getLocalizedReason() -> String {
        switch biometricType() {
        case .faceID:
            return "ä½¿ç”¨é¢å®¹IDè§£é”ç§å¯†ç©ºé—´"
        case .touchID:
            return "ä½¿ç”¨è§¦æ§IDè§£é”ç§å¯†ç©ºé—´"
        case .none:
            return "è§£é”ç§å¯†ç©ºé—´"
        }
    }
    
    /// å¤„ç†ç”Ÿç‰©è¯†åˆ«é”™è¯¯
    private func handleBiometricError(_ error: LAError) {
        switch error.code {
        case .authenticationFailed:
            print("âš ï¸ è®¤è¯å¤±è´¥: ç”¨æˆ·æœªèƒ½è¢«è¯†åˆ«")
        case .userCancel:
            print("âš ï¸ ç”¨æˆ·å–æ¶ˆè®¤è¯")
        case .userFallback:
            print("âš ï¸ ç”¨æˆ·é€‰æ‹©ä½¿ç”¨å¯†ç ")
        case .biometryNotAvailable:
            print("âš ï¸ ç”Ÿç‰©è¯†åˆ«ä¸å¯ç”¨")
        case .biometryNotEnrolled:
            print("âš ï¸ ç”¨æˆ·æœªè®¾ç½®ç”Ÿç‰©è¯†åˆ«")
        case .biometryLockout:
            print("âš ï¸ ç”Ÿç‰©è¯†åˆ«å·²é”å®šï¼Œéœ€è¦ä½¿ç”¨å¯†ç ")
        default:
            print("âš ï¸ å…¶ä»–é”™è¯¯: \(error.localizedDescription)")
        }
    }
}
```

**Step 3: AppSettings æ·»åŠ ç”Ÿç‰©è¯†åˆ«å¼€å…³** (30åˆ†é’Ÿ)

```swift
// File: ZeroNet-Space/Models/AppSettings.swift

class AppSettings: ObservableObject {
    // ... ç°æœ‰ä»£ç  ...
    
    /// æ˜¯å¦å¯ç”¨ç”Ÿç‰©è¯†åˆ«
    @Published var isBiometricEnabled: Bool {
        didSet {
            defaults.set(isBiometricEnabled, 
                        forKey: AppConstants.UserDefaultsKeys.biometricEnabled)
            print("ğŸ“ ç”Ÿç‰©è¯†åˆ«è®¾ç½®å·²æ›´æ–°: \(isBiometricEnabled)")
        }
    }
    
    private init() {
        // ... ç°æœ‰åˆå§‹åŒ–ä»£ç  ...
        
        // è¯»å–ç”Ÿç‰©è¯†åˆ«è®¾ç½®
        self.isBiometricEnabled = defaults.bool(
            forKey: AppConstants.UserDefaultsKeys.biometricEnabled
        )
    }
}

// AppConstants.swift æ·»åŠ :
struct UserDefaultsKeys {
    static let biometricEnabled = "biometricEnabled"
}
```

**Step 4: LoginView é›†æˆç”Ÿç‰©è¯†åˆ«** (2å°æ—¶)

```swift
// File: ZeroNet-Space/Views/Authentication/LoginView.swift

struct LoginView: View {
    @EnvironmentObject private var viewModel: AuthenticationViewModel
    @StateObject private var settings = AppSettings.shared
    @State private var showBiometricButton = false
    
    var body: some View {
        NavigationStack {
            ZStack {
                // ... ç°æœ‰èƒŒæ™¯å’Œå†…å®¹ ...
                
                ScrollView {
                    VStack(spacing: 30) {
                        headerSection
                        passwordSection
                        loginButton
                        
                        // æ–°å¢: ç”Ÿç‰©è¯†åˆ«æŒ‰é’®
                        if showBiometricButton {
                            biometricButton
                        }
                        
                        forgotPasswordHint
                    }
                }
            }
            .task {
                // æ£€æŸ¥æ˜¯å¦æ˜¾ç¤ºç”Ÿç‰©è¯†åˆ«æŒ‰é’®
                if settings.isBiometricEnabled && 
                   BiometricAuthService.shared.isBiometricAvailable {
                    showBiometricButton = true
                    
                    // è‡ªåŠ¨è§¦å‘ç”Ÿç‰©è¯†åˆ« (å¯é€‰)
                    await attemptBiometricAuth()
                }
            }
        }
    }
    
    // MARK: - Biometric Button (æ–°å¢)
    
    private var biometricButton: some View {
        VStack(spacing: 12) {
            Divider()
                .padding(.horizontal)
            
            Button {
                Task {
                    await attemptBiometricAuth()
                }
            } label: {
                VStack(spacing: 8) {
                    Image(systemName: biometricIconName)
                        .font(.system(size: 40))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [.blue, .purple],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                    
                    Text(biometricButtonText)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
            }
            .padding(.top, 8)
        }
    }
    
    // MARK: - Biometric Helpers (æ–°å¢)
    
    private var biometricIconName: String {
        switch BiometricAuthService.shared.biometricType() {
        case .faceID:
            return "faceid"
        case .touchID:
            return "touchid"
        case .none:
            return "lock.shield"
        }
    }
    
    private var biometricButtonText: String {
        switch BiometricAuthService.shared.biometricType() {
        case .faceID:
            return "ä½¿ç”¨é¢å®¹IDè§£é”"
        case .touchID:
            return "ä½¿ç”¨è§¦æ§IDè§£é”"
        case .none:
            return "ä½¿ç”¨ç”Ÿç‰©è¯†åˆ«"
        }
    }
    
    private func attemptBiometricAuth() async {
        let success = await BiometricAuthService.shared.authenticate()
        
        if success {
            await MainActor.run {
                // ç”Ÿç‰©è¯†åˆ«æˆåŠŸï¼Œè‡ªåŠ¨ç™»å½•
                // æ³¨æ„: ä»éœ€è¦æä¾›å¯†ç  (ä» Keychain è¯»å–ç”¨äºè§£å¯†)
                viewModel.loginWithBiometric()
            }
        }
    }
}
```

**Step 5: AuthenticationViewModel æ·»åŠ ç”Ÿç‰©è¯†åˆ«ç™»å½•** (1å°æ—¶)

```swift
// File: ZeroNet-Space/ViewModels/AuthenticationViewModel.swift

class AuthenticationViewModel: ObservableObject {
    // ... ç°æœ‰ä»£ç  ...
    
    /// ä½¿ç”¨ç”Ÿç‰©è¯†åˆ«ç™»å½•
    func loginWithBiometric() {
        // ç”Ÿç‰©è¯†åˆ«æˆåŠŸåï¼Œç›´æ¥æ ‡è®°ä¸ºå·²è®¤è¯
        // å¯†ç ä»ä» Keychain è¯»å–ç”¨äºæ–‡ä»¶è§£å¯†
        guard let savedPassword = getSavedPassword() else {
            errorMessage = "æ— æ³•è¯»å–ä¿å­˜çš„å¯†ç "
            return
        }
        
        sessionPassword = savedPassword
        isAuthenticated = true
        errorMessage = nil
        
        print("âœ… ç”Ÿç‰©è¯†åˆ«ç™»å½•æˆåŠŸ")
    }
    
    /// ä» Keychain è¯»å–å¯†ç  (ç§æœ‰æ–¹æ³•)
    private func getSavedPassword() -> String? {
        // æ³¨æ„: è¿™éœ€è¦å¯†ç ä»¥æ˜æ–‡å½¢å¼ä¿å­˜åœ¨ Keychain ä¸­
        // æˆ–è€…ä½¿ç”¨åŠ å¯†çš„å½¢å¼ä¿å­˜
        // å½“å‰å®ç°åªä¿å­˜äº†å“ˆå¸Œ,éœ€è¦è°ƒæ•´
        
        // ä¸´æ—¶æ–¹æ¡ˆ: ç”¨æˆ·é¦–æ¬¡è®¾ç½®å¯†ç æ—¶åŒæ—¶ä¿å­˜æ˜æ–‡å¯†ç åˆ° Keychain
        // (ä»…ç”¨äºç”Ÿç‰©è¯†åˆ«åœºæ™¯)
        return KeychainService.shared.getPassword()
    }
}
```

**Step 6: KeychainService æ”¯æŒæ˜æ–‡å¯†ç å­˜å‚¨** (1å°æ—¶)

```swift
// File: ZeroNet-Space/Services/KeychainService.swift

class KeychainService {
    // ... ç°æœ‰ä»£ç  ...
    
    private let passwordKey = "userPassword"  // æ–°å¢: æ˜æ–‡å¯†ç  key
    
    /// ä¿å­˜æ˜æ–‡å¯†ç  (ä»…ç”¨äºç”Ÿç‰©è¯†åˆ«)
    func savePassword(_ password: String) -> Bool {
        guard !password.isEmpty else {
            print("âŒ å¯†ç ä¸ºç©º")
            return false
        }
        
        let passwordData = Data(password.utf8)
        
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: passwordKey,
            kSecValueData as String: passwordData,
            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly
        ]
        
        // å…ˆåˆ é™¤æ—§æ•°æ®
        SecItemDelete(query as CFDictionary)
        
        // æ·»åŠ æ–°æ•°æ®
        let status = SecItemAdd(query as CFDictionary, nil)
        
        if status == errSecSuccess {
            print("âœ… å¯†ç å·²ä¿å­˜åˆ°Keychain (æ˜æ–‡,ç”¨äºç”Ÿç‰©è¯†åˆ«)")
            return true
        } else {
            print("âŒ ä¿å­˜å¯†ç å¤±è´¥: \(status)")
            return false
        }
    }
    
    /// è¯»å–æ˜æ–‡å¯†ç 
    func getPassword() -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: passwordKey,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        
        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)
        
        guard status == errSecSuccess,
              let data = result as? Data,
              let password = String(data: data, encoding: .utf8) else {
            return nil
        }
        
        return password
    }
    
    /// åˆ é™¤æ˜æ–‡å¯†ç 
    func deletePassword() -> Bool {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: passwordKey
        ]
        
        let status = SecItemDelete(query as CFDictionary)
        return status == errSecSuccess
    }
}
```

**Step 7: SetupPasswordView ä¿å­˜æ˜æ–‡å¯†ç ** (15åˆ†é’Ÿ)

```swift
// File: ZeroNet-Space/Views/Authentication/SetupPasswordView.swift

struct SetupPasswordView: View {
    // ... ç°æœ‰ä»£ç  ...
    
    private func setupPassword() {
        // ... ç°æœ‰éªŒè¯ä»£ç  ...
        
        // ä¿å­˜å¯†ç å“ˆå¸Œ
        let success = KeychainService.shared.savePasswordHash(password)
        
        // æ–°å¢: å¦‚æœå¯ç”¨ç”Ÿç‰©è¯†åˆ«,ä¿å­˜æ˜æ–‡å¯†ç 
        if settings.isBiometricEnabled && BiometricAuthService.shared.isBiometricAvailable {
            _ = KeychainService.shared.savePassword(password)
        }
        
        // ... å…¶ä½™ä»£ç  ...
    }
}
```

**Step 8: SettingsView æ·»åŠ ç”Ÿç‰©è¯†åˆ«å¼€å…³** (30åˆ†é’Ÿ)

```swift
// File: ZeroNet-Space/Views/Settings/SettingsView.swift

struct SettingsView: View {
    var body: some View {
        List {
            // ... ç°æœ‰åŒºåŸŸ ...
            
            // ä¿®æ”¹: å®‰å…¨è®¾ç½®åŒºåŸŸ
            securitySection
        }
    }
    
    private var securitySection: some View {
        Section {
            // æ–°å¢: ç”Ÿç‰©è¯†åˆ«å¼€å…³
            if BiometricAuthService.shared.isBiometricAvailable {
                biometricToggle
            }
            
            // ä¿®æ”¹å¯†ç 
            Button {
                showChangePasswordSheet = true
            } label: {
                Label("ä¿®æ”¹å¯†ç ", systemImage: "key.fill")
                    .foregroundColor(.primary)
            }
            
            // é€€å‡ºç™»å½•
            Button {
                showLogoutConfirmation = true
            } label: {
                Label("é€€å‡ºç™»å½•", systemImage: "rectangle.portrait.and.arrow.right")
                    .foregroundColor(.red)
            }
            
        } header: {
            Label("å®‰å…¨è®¾ç½®", systemImage: "lock.shield")
        }
    }
    
    // MARK: - Biometric Toggle (æ–°å¢)
    
    private var biometricToggle: some View {
        Toggle(isOn: $settings.isBiometricEnabled) {
            Label(biometricToggleText, systemImage: biometricIconName)
        }
        .onChange(of: settings.isBiometricEnabled) { _, newValue in
            handleBiometricToggle(newValue)
        }
    }
    
    private var biometricToggleText: String {
        switch BiometricAuthService.shared.biometricType() {
        case .faceID:
            return "é¢å®¹IDè§£é”"
        case .touchID:
            return "è§¦æ§IDè§£é”"
        case .none:
            return "ç”Ÿç‰©è¯†åˆ«è§£é”"
        }
    }
    
    private var biometricIconName: String {
        switch BiometricAuthService.shared.biometricType() {
        case .faceID:
            return "faceid"
        case .touchID:
            return "touchid"
        case .none:
            return "lock.shield"
        }
    }
    
    private func handleBiometricToggle(_ enabled: Bool) {
        if enabled {
            // å¼€å¯ç”Ÿç‰©è¯†åˆ«: éœ€è¦ä¿å­˜å¯†ç åˆ° Keychain
            // æç¤ºç”¨æˆ·éœ€è¦é‡æ–°è¾“å…¥å¯†ç 
            showBiometricSetupAlert = true
        } else {
            // å…³é—­ç”Ÿç‰©è¯†åˆ«: åˆ é™¤æ˜æ–‡å¯†ç 
            _ = KeychainService.shared.deletePassword()
            print("ğŸ—‘ï¸ å·²åˆ é™¤ Keychain ä¸­çš„æ˜æ–‡å¯†ç ")
        }
    }
}
```

**æµ‹è¯•æ¸…å•**:
- [ ] Face ID è§£é”æˆåŠŸ
- [ ] Touch ID è§£é”æˆåŠŸ
- [ ] ç”Ÿç‰©è¯†åˆ«å¤±è´¥åå›é€€åˆ°å¯†ç 
- [ ] è®¾ç½®ä¸­å¼€å¯/å…³é—­ç”Ÿç‰©è¯†åˆ«
- [ ] å¯†ç ä¿®æ”¹åç”Ÿç‰©è¯†åˆ«ä»å¯ç”¨

---

### ä»»åŠ¡ 1.3: æ— ç½‘ç»œéªŒè¯ç•Œé¢ â­ P0

**ç›®æ ‡**: å‘ç”¨æˆ·å±•ç¤ºåº”ç”¨å®Œå…¨ç¦»çº¿çš„æŠ€æœ¯è¯æ˜

**å·¥ä½œé‡**: 2 å¤©

#### å®ç°æ­¥éª¤

**Step 1: åˆ›å»ºç½‘ç»œéªŒè¯è§†å›¾** (å·²å­˜åœ¨,éœ€å¢å¼º)

```swift
// File: ZeroNet-Space/Views/Security/NetworkVerificationView.swift
// å½“å‰å·²æœ‰åŸºç¡€å®ç°,éœ€è¦å¢å¼ºå†…å®¹

import SwiftUI
import Network

struct NetworkVerificationView: View {
    @State private var hasNetworkPermission = false
    @State private var networkStatus: String = "æ£€æŸ¥ä¸­..."
    @State private var showTechnicalDetails = false
    
    var body: some View {
        List {
            // æ ¸å¿ƒéªŒè¯åŒºåŸŸ
            verificationSection
            
            // æŠ€æœ¯ç»†èŠ‚
            if showTechnicalDetails {
                technicalDetailsSection
            }
            
            // å¦‚ä½•éªŒè¯è¯´æ˜
            howToVerifySection
        }
        .navigationTitle("é›¶ç½‘ç»œéªŒè¯")
        .navigationBarTitleDisplayMode(.inline)
        .task {
            checkNetworkPermissions()
        }
    }
    
    // MARK: - Verification Section
    
    private var verificationSection: some View {
        Section {
            // ç½‘ç»œæƒé™æ£€æŸ¥
            HStack {
                Image(systemName: hasNetworkPermission ? "wifi.exclamationmark" : "wifi.slash")
                    .foregroundColor(hasNetworkPermission ? .red : .green)
                    .font(.title2)
                
                VStack(alignment: .leading, spacing: 4) {
                    Text("ç½‘ç»œæƒé™")
                        .font(.headline)
                    Text(hasNetworkPermission ? "å·²æˆæƒ (å¼‚å¸¸!)" : "æœªæˆæƒ âœ“")
                        .font(.subheadline)
                        .foregroundColor(hasNetworkPermission ? .red : .green)
                }
                
                Spacer()
                
                Image(systemName: hasNetworkPermission ? "xmark.circle.fill" : "checkmark.circle.fill")
                    .foregroundColor(hasNetworkPermission ? .red : .green)
                    .font(.title3)
            }
            
            // ç½‘ç»œçŠ¶æ€
            HStack {
                Image(systemName: "network")
                    .foregroundColor(.blue)
                    .font(.title2)
                
                VStack(alignment: .leading, spacing: 4) {
                    Text("ç½‘ç»œè¿æ¥")
                        .font(.headline)
                    Text(networkStatus)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
            }
            
            // SDKæ£€æŸ¥
            HStack {
                Image(systemName: "app.badge.checkmark")
                    .foregroundColor(.green)
                    .font(.title2)
                
                VStack(alignment: .leading, spacing: 4) {
                    Text("ç¬¬ä¸‰æ–¹SDK")
                        .font(.headline)
                    Text("é›¶SDK âœ“")
                        .font(.subheadline)
                        .foregroundColor(.green)
                }
                
                Spacer()
                
                Image(systemName: "checkmark.circle.fill")
                    .foregroundColor(.green)
                    .font(.title3)
            }
            
        } header: {
            Label("æ ¸å¿ƒéªŒè¯", systemImage: "checkmark.shield.fill")
                .foregroundColor(.green)
        } footer: {
            Text("åº”ç”¨æœªè¯·æ±‚ä»»ä½•ç½‘ç»œç›¸å…³æƒé™ï¼Œæ‰€æœ‰æ•°æ®100%æœ¬åœ°å­˜å‚¨")
        }
    }
    
    // MARK: - Technical Details Section
    
    private var technicalDetailsSection: some View {
        Section {
            DetailRow(
                title: "Info.plist æƒé™",
                value: "æ— ç½‘ç»œæƒé™è¯·æ±‚",
                icon: "doc.text.fill",
                iconColor: .green
            )
            
            DetailRow(
                title: "ATS (App Transport Security)",
                value: "å·²ç¦ç”¨æ‰€æœ‰ç½‘ç»œè¿æ¥",
                icon: "network.slash",
                iconColor: .green
            )
            
            DetailRow(
                title: "NSAppTransportSecurity",
                value: "æœªé…ç½® (æ— éœ€ç½‘ç»œ)",
                icon: "shield.checkered",
                iconColor: .green
            )
            
            DetailRow(
                title: "URLSession",
                value: "æœªåˆå§‹åŒ–",
                icon: "globe.slash",
                iconColor: .green
            )
            
            DetailRow(
                title: "ç¬¬ä¸‰æ–¹æ¡†æ¶",
                value: "é›¶ä¾èµ–",
                icon: "cube.box",
                iconColor: .green
            )
            
            DetailRow(
                title: "ç»Ÿè®¡/åˆ†æ",
                value: "é›¶è¿½è¸ª",
                icon: "chart.bar.xaxis",
                iconColor: .green
            )
            
        } header: {
            HStack {
                Label("æŠ€æœ¯ç»†èŠ‚", systemImage: "gearshape.2.fill")
                Spacer()
                Button(showTechnicalDetails ? "æ”¶èµ·" : "å±•å¼€") {
                    withAnimation {
                        showTechnicalDetails.toggle()
                    }
                }
                .font(.caption)
            }
        }
    }
    
    // MARK: - How To Verify Section
    
    private var howToVerifySection: some View {
        Section {
            VStack(alignment: .leading, spacing: 12) {
                Text("å¦‚ä½•éªŒè¯åº”ç”¨å®Œå…¨ç¦»çº¿ï¼Ÿ")
                    .font(.headline)
                
                verificationStep(
                    number: 1,
                    title: "å¼€å¯é£è¡Œæ¨¡å¼",
                    description: "åœ¨è®¾å¤‡è®¾ç½®ä¸­å¼€å¯é£è¡Œæ¨¡å¼ï¼Œæ–­å¼€æ‰€æœ‰ç½‘ç»œè¿æ¥"
                )
                
                verificationStep(
                    number: 2,
                    title: "ä½¿ç”¨åº”ç”¨",
                    description: "åœ¨é£è¡Œæ¨¡å¼ä¸‹ï¼Œåº”ç”¨çš„æ‰€æœ‰åŠŸèƒ½ä»ç„¶æ­£å¸¸å·¥ä½œ"
                )
                
                verificationStep(
                    number: 3,
                    title: "æ£€æŸ¥æƒé™",
                    description: "å‰å¾€ è®¾ç½® > é›¶ç½‘ç»œç©ºé—´ï¼ŒæŸ¥çœ‹æƒé™åˆ—è¡¨ä¸ºç©º"
                )
                
                verificationStep(
                    number: 4,
                    title: "æ•°æ®éªŒè¯",
                    description: "æ‰€æœ‰ç…§ç‰‡ã€è§†é¢‘å’Œæ–‡ä»¶ä»…å­˜å‚¨åœ¨æœ¬åœ°è®¾å¤‡ä¸Š"
                )
            }
            .padding(.vertical, 4)
            
        } header: {
            Label("éªŒè¯æ–¹æ³•", systemImage: "list.bullet.clipboard")
        }
    }
    
    // MARK: - Helper Views
    
    private func verificationStep(number: Int, title: String, description: String) -> some View {
        HStack(alignment: .top, spacing: 12) {
            ZStack {
                Circle()
                    .fill(Color.blue.opacity(0.2))
                    .frame(width: 32, height: 32)
                
                Text("\(number)")
                    .font(.headline)
                    .foregroundColor(.blue)
            }
            
            VStack(alignment: .leading, spacing: 4) {
                Text(title)
                    .font(.subheadline)
                    .fontWeight(.semibold)
                
                Text(description)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
    }
    
    // MARK: - Methods
    
    private func checkNetworkPermissions() {
        // æ£€æŸ¥åº”ç”¨æ˜¯å¦æœ‰ç½‘ç»œæƒé™
        // æ³¨æ„: iOS ä¸æä¾›ç›´æ¥APIæ£€æŸ¥,æˆ‘ä»¬é€šè¿‡Info.plisté—´æ¥éªŒè¯
        
        // æ£€æŸ¥ Info.plist ä¸­æ˜¯å¦æœ‰ç½‘ç»œç›¸å…³é…ç½®
        let bundle = Bundle.main
        
        // æ£€æŸ¥å¸¸è§çš„ç½‘ç»œæƒé™ key
        let networkKeys = [
            "NSAppTransportSecurity",
            "NSAllowsArbitraryLoads",
            "NSExceptionDomains"
        ]
        
        var hasAnyNetworkConfig = false
        for key in networkKeys {
            if bundle.object(forInfoDictionaryKey: key) != nil {
                hasAnyNetworkConfig = true
                break
            }
        }
        
        hasNetworkPermission = hasAnyNetworkConfig
        
        // å°è¯•æ£€æµ‹ç½‘ç»œçŠ¶æ€ (åº”è¯¥å¤±è´¥æˆ–æ— å“åº”)
        checkNetworkStatus()
    }
    
    private func checkNetworkStatus() {
        let monitor = NWPathMonitor()
        let queue = DispatchQueue(label: "NetworkMonitor")
        
        monitor.pathUpdateHandler = { path in
            DispatchQueue.main.async {
                // æ³¨æ„: è¿™åªæ£€æµ‹è®¾å¤‡çš„ç½‘ç»œè¿æ¥,ä¸æ˜¯åº”ç”¨çš„ç½‘ç»œæƒé™
                if path.status == .satisfied {
                    networkStatus = "è®¾å¤‡å·²è”ç½‘ (åº”ç”¨æœªä½¿ç”¨)"
                } else {
                    networkStatus = "è®¾å¤‡æœªè”ç½‘"
                }
                
                // æ£€æµ‹è¿æ¥ç±»å‹
                if path.usesInterfaceType(.wifi) {
                    networkStatus += " (Wi-Fi)"
                } else if path.usesInterfaceType(.cellular) {
                    networkStatus += " (èœ‚çª)"
                }
            }
        }
        
        monitor.start(queue: queue)
        
        // 5ç§’ååœæ­¢ç›‘æ§
        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
            monitor.cancel()
        }
    }
}

// MARK: - Detail Row

struct DetailRow: View {
    let title: String
    let value: String
    let icon: String
    let iconColor: Color
    
    var body: some View {
        HStack {
            Image(systemName: icon)
                .foregroundColor(iconColor)
                .frame(width: 24)
            
            VStack(alignment: .leading, spacing: 2) {
                Text(title)
                    .font(.subheadline)
                Text(value)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
    }
}

// MARK: - Preview

#Preview {
    NavigationStack {
        NetworkVerificationView()
    }
}
```

**Step 2: SettingsView æ·»åŠ å…¥å£** (å·²å­˜åœ¨,ç¡®è®¤ä½ç½®)

```swift
// File: ZeroNet-Space/Views/Settings/SettingsView.swift

private var aboutSection: some View {
    Section {
        // ... ç°æœ‰å†…å®¹ ...
        
        // é›¶ç½‘ç»œéªŒè¯ (å·²å­˜åœ¨,ç¡®è®¤æ˜¾çœ¼ä½ç½®)
        NavigationLink {
            NetworkVerificationView()
        } label: {
            Label("é›¶ç½‘ç»œéªŒè¯", systemImage: "network.slash")
                .foregroundColor(.green)  // çªå‡ºæ˜¾ç¤º
        }
        
    } header: {
        Label("å…³äº", systemImage: "questionmark.circle")
    }
}
```

**æµ‹è¯•æ¸…å•**:
- [ ] æ˜¾ç¤ºç½‘ç»œæƒé™çŠ¶æ€
- [ ] æ˜¾ç¤ºSDKä½¿ç”¨æƒ…å†µ
- [ ] æŠ€æœ¯ç»†èŠ‚å¯å±•å¼€/æ”¶èµ·
- [ ] éªŒè¯æ–¹æ³•æ¸…æ™°æ˜“æ‡‚
- [ ] é£è¡Œæ¨¡å¼ä¸‹åº”ç”¨æ­£å¸¸å·¥ä½œ

---

## Week 2: P1 æ ¸å¿ƒåŠŸèƒ½ - éšè—ç©ºé—´

### ä»»åŠ¡ 2.1: éšè—ç©ºé—´ â­ P1

**ç›®æ ‡**: ç‰¹æ®Šæ‰‹åŠ¿è¿›å…¥éšè—ç©ºé—´,ç‹¬ç«‹å¯†ç ä¿æŠ¤

**å·¥ä½œé‡**: 3-5 å¤©

#### æ¶æ„è®¾è®¡

**æ•°æ®æ¨¡å‹è®¾è®¡**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          MediaItem                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - id: UUID                          â”‚
â”‚ - fileName: String                  â”‚
â”‚ - spaceType: SpaceType  â† æ–°å¢     â”‚
â”‚ - ... (å…¶ä»–ç°æœ‰å±æ€§)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   SpaceType     â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ - main          â”‚
    â”‚ - hidden        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     HiddenSpaceSettings  â† æ–°å¢     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - isEnabled: Bool                   â”‚
â”‚ - gestureType: GestureType          â”‚
â”‚ - gesturePattern: String            â”‚
â”‚ - createdAt: Date                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ‰‹åŠ¿ç±»å‹è®¾è®¡**:

```
GestureType:
1. è¿ç»­ç‚¹å‡» (TapSequence): ç‚¹å‡»å±å¹•ç‰¹å®šä½ç½®Næ¬¡
2. æ»‘åŠ¨æ¨¡å¼ (SwipePattern): ç‰¹å®šæ–¹å‘æ»‘åŠ¨åºåˆ— (ä¸Šä¸‹å·¦å³)
3. å›¾å½¢ç»˜åˆ¶ (ShapeDrawing): ç»˜åˆ¶ç‰¹å®šå›¾å½¢ (Zå­—ã€åœ†å½¢ç­‰)
4. é•¿æŒ‰ç»„åˆ (LongPressCombination): é•¿æŒ‰+ç‚¹å‡»ç»„åˆ
```

#### å®ç°æ­¥éª¤

**Step 1: åˆ›å»º SpaceType æšä¸¾** (30åˆ†é’Ÿ)

```swift
// File: ZeroNet-Space/Models/SpaceType.swift

import Foundation

/// ç©ºé—´ç±»å‹
enum SpaceType: String, Codable, CaseIterable {
    case main = "main"      // ä¸»ç©ºé—´
    case hidden = "hidden"  // éšè—ç©ºé—´
    
    var displayName: String {
        switch self {
        case .main:
            return "ä¸»ç©ºé—´"
        case .hidden:
            return "éšè—ç©ºé—´"
        }
    }
    
    var iconName: String {
        switch self {
        case .main:
            return "folder"
        case .hidden:
            return "eye.slash.fill"
        }
    }
}
```

**Step 2: æ‰©å±• MediaItem æ¨¡å‹** (15åˆ†é’Ÿ)

```swift
// File: ZeroNet-Space/Models/MediaItem.swift

@Model
final class MediaItem {
    // ... ç°æœ‰å±æ€§ ...
    
    /// ç©ºé—´ç±»å‹ (æ–°å¢)
    var spaceType: SpaceType = .main
    
    init(
        fileName: String,
        fileExtension: String,
        fileSizeBytes: Int,
        mediaType: MediaType,
        encryptedPath: String,
        thumbnailData: Data? = nil,
        folder: Folder? = nil,
        tags: [Tag]? = nil,
        spaceType: SpaceType = .main  // æ–°å¢å‚æ•°
    ) {
        // ... ç°æœ‰åˆå§‹åŒ–ä»£ç  ...
        self.spaceType = spaceType  // æ–°å¢
    }
}
```

**Step 3: åˆ›å»ºéšè—ç©ºé—´ç®¡ç†å™¨** (4å°æ—¶)

```swift
// File: ZeroNet-Space/Services/HiddenSpaceManager.swift

import SwiftUI
import Combine

/// æ‰‹åŠ¿ç±»å‹
enum GestureType: String, CaseIterable, Codable {
    case tapSequence = "è¿ç»­ç‚¹å‡»"
    case swipePattern = "æ»‘åŠ¨æ¨¡å¼"
    case shapeDrawing = "å›¾å½¢ç»˜åˆ¶"
    case longPressCombination = "é•¿æŒ‰ç»„åˆ"
    
    var iconName: String {
        switch self {
        case .tapSequence:
            return "hand.tap.fill"
        case .swipePattern:
            return "hand.draw.fill"
        case .shapeDrawing:
            return "scribble"
        case .longPressCombination:
            return "hand.point.up.left.fill"
        }
    }
    
    var description: String {
        switch self {
        case .tapSequence:
            return "åœ¨å±å¹•ç‰¹å®šä½ç½®è¿ç»­ç‚¹å‡»"
        case .swipePattern:
            return "æŒ‰ç‰¹å®šæ–¹å‘æ»‘åŠ¨åºåˆ—"
        case .shapeDrawing:
            return "ç»˜åˆ¶ç‰¹å®šå›¾å½¢"
        case .longPressCombination:
            return "é•¿æŒ‰+ç‚¹å‡»ç»„åˆ"
        }
    }
}

/// éšè—ç©ºé—´ç®¡ç†å™¨
class HiddenSpaceManager: ObservableObject {
    
    // MARK: - Singleton
    
    static let shared = HiddenSpaceManager()
    private init() {
        loadSettings()
    }
    
    // MARK: - Published Properties
    
    /// æ˜¯å¦å¯ç”¨éšè—ç©ºé—´
    @Published var isEnabled: Bool = false {
        didSet {
            saveSettings()
        }
    }
    
    /// å½“å‰æ´»åŠ¨ç©ºé—´
    @Published var currentSpace: SpaceType = .main
    
    /// æ‰‹åŠ¿ç±»å‹
    @Published var gestureType: GestureType = .tapSequence {
        didSet {
            saveSettings()
        }
    }
    
    /// æ‰‹åŠ¿æ¨¡å¼ (ç¼–ç åçš„å­—ç¬¦ä¸²)
    @Published var gesturePattern: String = "" {
        didSet {
            saveSettings()
        }
    }
    
    // MARK: - UserDefaults Keys
    
    private let defaults = UserDefaults.standard
    private let isEnabledKey = "hiddenSpace_isEnabled"
    private let gestureTypeKey = "hiddenSpace_gestureType"
    private let gesturePatternKey = "hiddenSpace_gesturePattern"
    
    // MARK: - Public Methods
    
    /// éªŒè¯æ‰‹åŠ¿
    func verifyGesture(_ input: String) -> Bool {
        guard isEnabled else { return false }
        guard !gesturePattern.isEmpty else { return false }
        
        let isMatch = input == gesturePattern
        
        if isMatch {
            print("âœ… éšè—ç©ºé—´æ‰‹åŠ¿éªŒè¯æˆåŠŸ")
        } else {
            print("âŒ éšè—ç©ºé—´æ‰‹åŠ¿éªŒè¯å¤±è´¥")
        }
        
        return isMatch
    }
    
    /// åˆ‡æ¢åˆ°éšè—ç©ºé—´
    func switchToHiddenSpace() {
        guard isEnabled else { return }
        
        withAnimation {
            currentSpace = .hidden
        }
        
        print("ğŸ”„ å·²åˆ‡æ¢åˆ°éšè—ç©ºé—´")
    }
    
    /// åˆ‡æ¢åˆ°ä¸»ç©ºé—´
    func switchToMainSpace() {
        withAnimation {
            currentSpace = .main
        }
        
        print("ğŸ”„ å·²åˆ‡æ¢åˆ°ä¸»ç©ºé—´")
    }
    
    /// åˆ‡æ¢ç©ºé—´
    func toggleSpace() {
        if currentSpace == .main {
            switchToHiddenSpace()
        } else {
            switchToMainSpace()
        }
    }
    
    /// è®¾ç½®æ‰‹åŠ¿æ¨¡å¼
    func setGesturePattern(type: GestureType, pattern: String) {
        gestureType = type
        gesturePattern = pattern
        isEnabled = true
        
        print("âœ… éšè—ç©ºé—´æ‰‹åŠ¿å·²è®¾ç½®: \(type.rawValue)")
    }
    
    /// ç¦ç”¨éšè—ç©ºé—´
    func disable() {
        isEnabled = false
        gesturePattern = ""
        currentSpace = .main
        
        print("ğŸ”“ éšè—ç©ºé—´å·²ç¦ç”¨")
    }
    
    // MARK: - Private Methods
    
    private func loadSettings() {
        isEnabled = defaults.bool(forKey: isEnabledKey)
        
        if let typeString = defaults.string(forKey: gestureTypeKey),
           let type = GestureType(rawValue: typeString) {
            gestureType = type
        }
        
        gesturePattern = defaults.string(forKey: gesturePatternKey) ?? ""
        
        print("ğŸ“– éšè—ç©ºé—´è®¾ç½®å·²åŠ è½½")
    }
    
    private func saveSettings() {
        defaults.set(isEnabled, forKey: isEnabledKey)
        defaults.set(gestureType.rawValue, forKey: gestureTypeKey)
        defaults.set(gesturePattern, forKey: gesturePatternKey)
        
        print("ğŸ’¾ éšè—ç©ºé—´è®¾ç½®å·²ä¿å­˜")
    }
}
```

**Step 4: åˆ›å»ºæ‰‹åŠ¿æ£€æµ‹è§†å›¾** (8å°æ—¶ - æœ€å¤æ‚éƒ¨åˆ†)

```swift
// File: ZeroNet-Space/Views/HiddenSpace/HiddenSpaceGestureDetector.swift

import SwiftUI

/// éšè—ç©ºé—´æ‰‹åŠ¿æ£€æµ‹å™¨
/// è¦†ç›–åœ¨ä¸»ç•Œé¢ä¸Š,é€æ˜ä¸”ä¸å½±å“æ­£å¸¸æ“ä½œ
struct HiddenSpaceGestureDetector: View {
    @ObservedObject var hiddenSpaceManager = HiddenSpaceManager.shared
    @State private var gestureInput: String = ""
    @State private var tapCount: Int = 0
    @State private var lastTapTime: Date = Date()
    @State private var tapTimeout: Timer?
    
    private let tapTimeoutInterval: TimeInterval = 2.0  // 2ç§’å†…å®Œæˆè¿ç»­ç‚¹å‡»
    
    var body: some View {
        GeometryReader { geometry in
            Color.clear
                .contentShape(Rectangle())
                .simultaneousGesture(
                    TapGesture()
                        .onEnded {
                            handleTap(in: geometry.size)
                        }
                )
        }
    }
    
    private func handleTap(in size: CGSize) {
        let now = Date()
        let timeSinceLastTap = now.timeIntervalSince(lastTapTime)
        
        // å¦‚æœè·ç¦»ä¸Šæ¬¡ç‚¹å‡»è¶…è¿‡2ç§’,é‡ç½®è®¡æ•°
        if timeSinceLastTap > tapTimeoutInterval {
            tapCount = 0
            gestureInput = ""
        }
        
        tapCount += 1
        lastTapTime = now
        
        // å–æ¶ˆä¹‹å‰çš„è¶…æ—¶è®¡æ—¶å™¨
        tapTimeout?.invalidate()
        
        // è®¾ç½®æ–°çš„è¶…æ—¶è®¡æ—¶å™¨
        tapTimeout = Timer.scheduledTimer(withTimeInterval: tapTimeoutInterval, repeats: false) { _ in
            // è¶…æ—¶åé‡ç½®
            resetGestureInput()
        }
        
        // æ›´æ–°æ‰‹åŠ¿è¾“å…¥
        gestureInput += "\(tapCount)"
        
        // æ£€æŸ¥æ˜¯å¦åŒ¹é…éšè—ç©ºé—´æ‰‹åŠ¿
        checkGesture()
        
        // æä¾›è§¦è§‰åé¦ˆ
        let impactFeedback = UIImpactFeedbackGenerator(style: .light)
        impactFeedback.impactOccurred()
        
        print("ğŸ”¢ ç‚¹å‡»è®¡æ•°: \(tapCount), è¾“å…¥: \(gestureInput)")
    }
    
    private func checkGesture() {
        // æ£€æŸ¥æ˜¯å¦åŒ¹é…éšè—ç©ºé—´æ‰‹åŠ¿
        if hiddenSpaceManager.verifyGesture(gestureInput) {
            // æ‰‹åŠ¿åŒ¹é…æˆåŠŸ
            successFeedback()
            
            // åˆ‡æ¢åˆ°éšè—ç©ºé—´
            hiddenSpaceManager.switchToHiddenSpace()
            
            // é‡ç½®
            resetGestureInput()
        } else if gestureInput.count >= 6 {
            // è¾“å…¥è¿‡é•¿ä½†ä¸åŒ¹é…,é‡ç½®
            failureFeedback()
            resetGestureInput()
        }
    }
    
    private func resetGestureInput() {
        tapCount = 0
        gestureInput = ""
        tapTimeout?.invalidate()
        tapTimeout = nil
    }
    
    private func successFeedback() {
        let notificationFeedback = UINotificationFeedbackGenerator()
        notificationFeedback.notificationOccurred(.success)
    }
    
    private func failureFeedback() {
        let notificationFeedback = UINotificationFeedbackGenerator()
        notificationFeedback.notificationOccurred(.error)
    }
}

// MARK: - Preview

#Preview {
    ZStack {
        Color.gray.opacity(0.3)
        HiddenSpaceGestureDetector()
    }
}
```

**Step 5: é›†æˆåˆ° MainTabView** (1å°æ—¶)

```swift
// File: ZeroNet-Space/Views/MainTabView.swift

struct MainTabView: View {
    @EnvironmentObject var authViewModel: AuthenticationViewModel
    @StateObject private var hiddenSpaceManager = HiddenSpaceManager.shared
    @State private var selectedTab = 0
    
    var body: some View {
        ZStack {
            TabView(selection: $selectedTab) {
                // ... ç°æœ‰æ ‡ç­¾ ...
            }
            .tint(.blue)
            
            // å åŠ éšè—ç©ºé—´æ‰‹åŠ¿æ£€æµ‹å™¨ (æ–°å¢)
            if hiddenSpaceManager.isEnabled && hiddenSpaceManager.currentSpace == .main {
                HiddenSpaceGestureDetector()
            }
            
            // éšè—ç©ºé—´æŒ‡ç¤ºå™¨ (æ–°å¢)
            if hiddenSpaceManager.currentSpace == .hidden {
                VStack {
                    HStack {
                        Spacer()
                        hiddenSpaceIndicator
                    }
                    Spacer()
                }
                .padding()
            }
        }
    }
    
    // MARK: - Hidden Space Indicator (æ–°å¢)
    
    private var hiddenSpaceIndicator: some View {
        HStack(spacing: 8) {
            Image(systemName: "eye.slash.fill")
                .font(.caption)
            Text("éšè—ç©ºé—´")
                .font(.caption)
                .fontWeight(.semibold)
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 6)
        .background(
            Capsule()
                .fill(Color.purple.opacity(0.9))
        )
        .foregroundColor(.white)
        .shadow(radius: 4)
    }
}
```

**Step 6: è¿‡æ»¤æŸ¥è¯¢æ·»åŠ ç©ºé—´ç±»å‹** (2å°æ—¶)

```swift
// File: ZeroNet-Space/Views/Gallery/GalleryView.swift

struct GalleryView: View {
    @Environment(\.modelContext) private var modelContext
    @StateObject private var hiddenSpaceManager = HiddenSpaceManager.shared
    
    // ä¿®æ”¹æŸ¥è¯¢,æ·»åŠ ç©ºé—´ç±»å‹è¿‡æ»¤
    @Query private var allMediaItems: [MediaItem]
    
    init() {
        // ä½¿ç”¨ init æ—¶æ— æ³•è®¿é—® @StateObject,éœ€è¦åœ¨ body ä¸­è¿‡æ»¤
    }
    
    var body: some View {
        NavigationStack {
            // ... ç°æœ‰å†…å®¹ ...
        }
    }
    
    // è¿‡æ»¤å½“å‰ç©ºé—´çš„åª’ä½“é¡¹ (æ–°å¢)
    private var mediaItems: [MediaItem] {
        allMediaItems.filter { $0.spaceType == hiddenSpaceManager.currentSpace }
    }
}
```

**Step 7: è®¾ç½®ç•Œé¢ - éšè—ç©ºé—´é…ç½®** (4å°æ—¶)

```swift
// File: ZeroNet-Space/Views/Settings/HiddenSpaceSettingsView.swift

import SwiftUI

struct HiddenSpaceSettingsView: View {
    @StateObject private var manager = HiddenSpaceManager.shared
    @State private var showGestureSetup = false
    @State private var showDisableConfirmation = false
    
    var body: some View {
        List {
            // çŠ¶æ€åŒºåŸŸ
            statusSection
            
            // æ‰‹åŠ¿è®¾ç½®
            if manager.isEnabled {
                gestureSection
            }
            
            // æ“ä½œåŒºåŸŸ
            actionsSection
        }
        .navigationTitle("éšè—ç©ºé—´")
        .navigationBarTitleDisplayMode(.inline)
        .sheet(isPresented: $showGestureSetup) {
            GestureSetupView()
        }
        .confirmationDialog("ç¦ç”¨éšè—ç©ºé—´", isPresented: $showDisableConfirmation) {
            Button("ç¦ç”¨", role: .destructive) {
                manager.disable()
            }
            Button("å–æ¶ˆ", role: .cancel) {}
        } message: {
            Text("ç¦ç”¨éšè—ç©ºé—´å,éšè—ç©ºé—´ä¸­çš„æ‰€æœ‰æ–‡ä»¶å°†ç§»å›ä¸»ç©ºé—´")
        }
    }
    
    // MARK: - Status Section
    
    private var statusSection: some View {
        Section {
            HStack {
                Image(systemName: manager.isEnabled ? "eye.slash.fill" : "eye.fill")
                    .foregroundColor(manager.isEnabled ? .purple : .gray)
                    .font(.title2)
                
                VStack(alignment: .leading, spacing: 4) {
                    Text("éšè—ç©ºé—´")
                        .font(.headline)
                    Text(manager.isEnabled ? "å·²å¯ç”¨" : "æœªå¯ç”¨")
                        .font(.subheadline)
                        .foregroundColor(manager.isEnabled ? .purple : .secondary)
                }
                
                Spacer()
                
                if manager.isEnabled {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.green)
                        .font(.title3)
                }
            }
            
        } header: {
            Text("çŠ¶æ€")
        } footer: {
            Text("éšè—ç©ºé—´å…è®¸æ‚¨é€šè¿‡ç‰¹æ®Šæ‰‹åŠ¿è®¿é—®å¦ä¸€ä¸ªç‹¬ç«‹çš„ç§å¯†åŒºåŸŸ")
        }
    }
    
    // MARK: - Gesture Section
    
    private var gestureSection: some View {
        Section {
            HStack {
                Image(systemName: manager.gestureType.iconName)
                    .foregroundColor(.blue)
                    .frame(width: 24)
                
                VStack(alignment: .leading, spacing: 2) {
                    Text("æ‰‹åŠ¿ç±»å‹")
                        .font(.subheadline)
                    Text(manager.gestureType.rawValue)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                Button("ä¿®æ”¹") {
                    showGestureSetup = true
                }
                .font(.subheadline)
            }
            
        } header: {
            Text("æ‰‹åŠ¿è®¾ç½®")
        } footer: {
            Text(manager.gestureType.description)
        }
    }
    
    // MARK: - Actions Section
    
    private var actionsSection: some View {
        Section {
            if !manager.isEnabled {
                Button {
                    showGestureSetup = true
                } label: {
                    Label("å¯ç”¨éšè—ç©ºé—´", systemImage: "plus.circle.fill")
                        .foregroundColor(.blue)
                }
            } else {
                Button(role: .destructive) {
                    showDisableConfirmation = true
                } label: {
                    Label("ç¦ç”¨éšè—ç©ºé—´", systemImage: "xmark.circle.fill")
                }
            }
        }
    }
}

// MARK: - Gesture Setup View

struct GestureSetupView: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var manager = HiddenSpaceManager.shared
    @State private var selectedType: GestureType = .tapSequence
    @State private var gesturePattern: String = ""
    @State private var step: Int = 1
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 20) {
                if step == 1 {
                    gestureTypeSelection
                } else if step == 2 {
                    gesturePatternSetup
                }
                
                Spacer()
                
                navigationButtons
            }
            .padding()
            .navigationTitle("è®¾ç½®éšè—æ‰‹åŠ¿")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("å–æ¶ˆ") {
                        dismiss()
                    }
                }
            }
        }
    }
    
    // MARK: - Gesture Type Selection
    
    private var gestureTypeSelection: some View {
        VStack(spacing: 20) {
            Text("é€‰æ‹©æ‰‹åŠ¿ç±»å‹")
                .font(.title2)
                .fontWeight(.bold)
            
            ForEach(GestureType.allCases, id: \.self) { type in
                Button {
                    selectedType = type
                } label: {
                    HStack {
                        Image(systemName: type.iconName)
                            .font(.title2)
                            .frame(width: 40)
                        
                        VStack(alignment: .leading, spacing: 4) {
                            Text(type.rawValue)
                                .font(.headline)
                            Text(type.description)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        
                        Spacer()
                        
                        if selectedType == type {
                            Image(systemName: "checkmark.circle.fill")
                                .foregroundColor(.blue)
                        }
                    }
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(selectedType == type ? Color.blue.opacity(0.1) : Color(.systemGray6))
                    )
                }
                .buttonStyle(.plain)
            }
        }
    }
    
    // MARK: - Gesture Pattern Setup
    
    private var gesturePatternSetup: some View {
        VStack(spacing: 20) {
            Text("è®¾ç½®æ‰‹åŠ¿æ¨¡å¼")
                .font(.title2)
                .fontWeight(.bold)
            
            Text("ç¤ºä¾‹: è¿ç»­ç‚¹å‡»6æ¬¡")
                .font(.caption)
                .foregroundColor(.secondary)
            
            // æ ¹æ®æ‰‹åŠ¿ç±»å‹æ˜¾ç¤ºä¸åŒçš„è®¾ç½®ç•Œé¢
            switch selectedType {
            case .tapSequence:
                tapSequenceSetup
            case .swipePattern:
                Text("æ»‘åŠ¨æ¨¡å¼è®¾ç½® (å¾…å®ç°)")
            case .shapeDrawing:
                Text("å›¾å½¢ç»˜åˆ¶è®¾ç½® (å¾…å®ç°)")
            case .longPressCombination:
                Text("é•¿æŒ‰ç»„åˆè®¾ç½® (å¾…å®ç°)")
            }
        }
    }
    
    private var tapSequenceSetup: some View {
        VStack(spacing: 16) {
            Text("è®¾ç½®è¿ç»­ç‚¹å‡»æ¬¡æ•° (3-9æ¬¡)")
                .font(.subheadline)
            
            Picker("ç‚¹å‡»æ¬¡æ•°", selection: $gesturePattern) {
                ForEach(3...9, id: \.self) { count in
                    Text("\(count)æ¬¡").tag(String(repeating: "\(count)", count: 1))
                }
            }
            .pickerStyle(.wheel)
            .frame(height: 150)
            
            if !gesturePattern.isEmpty {
                Text("å°†è¿ç»­ç‚¹å‡»å±å¹• \(gesturePattern.count) æ¬¡è¿›å…¥éšè—ç©ºé—´")
                    .font(.caption)
                    .foregroundColor(.blue)
                    .padding()
                    .background(Color.blue.opacity(0.1))
                    .cornerRadius(8)
            }
        }
    }
    
    // MARK: - Navigation Buttons
    
    private var navigationButtons: some View {
        HStack {
            if step > 1 {
                Button("ä¸Šä¸€æ­¥") {
                    step -= 1
                }
                .buttonStyle(.bordered)
            }
            
            Spacer()
            
            Button(step == 2 ? "å®Œæˆ" : "ä¸‹ä¸€æ­¥") {
                if step == 1 {
                    step += 1
                } else {
                    // ä¿å­˜è®¾ç½®
                    saveGesturePattern()
                    dismiss()
                }
            }
            .buttonStyle(.borderedProminent)
            .disabled(step == 2 && gesturePattern.isEmpty)
        }
    }
    
    private func saveGesturePattern() {
        // ä¸ºè¿ç»­ç‚¹å‡»ç”Ÿæˆæ¨¡å¼å­—ç¬¦ä¸²
        var pattern = ""
        if selectedType == .tapSequence {
            // ä¾‹å¦‚: è®¾ç½®5æ¬¡ç‚¹å‡» â†’ pattern = "12345"
            for i in 1...5 {
                pattern += "\(i)"
            }
        }
        
        manager.setGesturePattern(type: selectedType, pattern: pattern)
        print("âœ… æ‰‹åŠ¿æ¨¡å¼å·²è®¾ç½®: \(pattern)")
    }
}

// MARK: - Preview

#Preview {
    NavigationStack {
        HiddenSpaceSettingsView()
    }
}
```

**Step 8: SettingsView æ·»åŠ å…¥å£** (15åˆ†é’Ÿ)

```swift
// File: ZeroNet-Space/Views/Settings/SettingsView.swift

private var securitySection: some View {
    Section {
        // æ–°å¢: éšè—ç©ºé—´è®¾ç½®
        NavigationLink {
            HiddenSpaceSettingsView()
        } label: {
            Label("éšè—ç©ºé—´", systemImage: "eye.slash.fill")
                .foregroundColor(.purple)
        }
        
        // ... ç°æœ‰å†…å®¹ ...
        
    } header: {
        Label("å®‰å…¨è®¾ç½®", systemImage: "lock.shield")
    }
}
```

**æµ‹è¯•æ¸…å•**:
- [ ] è®¾ç½®éšè—ç©ºé—´æ‰‹åŠ¿æˆåŠŸ
- [ ] æ‰‹åŠ¿éªŒè¯æˆåŠŸåˆ‡æ¢åˆ°éšè—ç©ºé—´
- [ ] ä¸»ç©ºé—´å’Œéšè—ç©ºé—´å†…å®¹å®Œå…¨éš”ç¦»
- [ ] éšè—ç©ºé—´æŒ‡ç¤ºå™¨æ­£ç¡®æ˜¾ç¤º
- [ ] ç¦ç”¨éšè—ç©ºé—´åŠŸèƒ½æ­£å¸¸
- [ ] é‡å¯åº”ç”¨åè®¾ç½®ä¿æŒ

---

## Week 3-4: P1 æ ¸å¿ƒåŠŸèƒ½ - ä¼ªè£…æ¨¡å¼

### ä»»åŠ¡ 3.1: ä¼ªè£…æ¨¡å¼ â­ P1

**ç›®æ ‡**: åŒå¯†ç ç³»ç»Ÿ,ä¼ªè£…å¯†ç æ˜¾ç¤ºå‡å†…å®¹

**å·¥ä½œé‡**: 4-6 å¤©

#### æ¶æ„è®¾è®¡

**åŒå¯†ç ç³»ç»Ÿ**:

```
ç”¨æˆ·è¾“å…¥å¯†ç 
      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å¯†ç éªŒè¯     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ çœŸå®å¯†ç ?   â”‚ â†’ Yes â†’ æ˜¾ç¤ºçœŸå®å†…å®¹ (currentMode = .real)
â”‚     â†“        â”‚
â”‚ ä¼ªè£…å¯†ç ?   â”‚ â†’ Yes â†’ æ˜¾ç¤ºä¼ªè£…å†…å®¹ (currentMode = .decoy)
â”‚     â†“        â”‚
â”‚ éƒ½ä¸æ˜¯      â”‚ â†’ é”™è¯¯æç¤º
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä¼ªè£…æ•°æ®ç­–ç•¥**:

```
é€‰é¡¹1: é¢„ç½®ä¼ªè£…æ•°æ®åŒ…
  - åº”ç”¨å†…ç½®ä¸€å¥—é£æ™¯ç…§/å…¬å¼€å›¾ç‰‡
  - ç”¨æˆ·æ— éœ€é¢å¤–æ“ä½œ
  - ç¼ºç‚¹: å ç”¨åŒ…ä½“ç§¯

é€‰é¡¹2: ç”¨æˆ·é€‰æ‹©ä¼ªè£…å†…å®¹ (æ¨è)
  - ç”¨æˆ·ä»ç›¸å†Œé€‰æ‹©"å…¬å¼€ç…§ç‰‡"ä½œä¸ºä¼ªè£…å†…å®¹
  - æ ‡è®°ä¸º isDecoy = true
  - ä¼˜ç‚¹: æ›´çœŸå®,æ›´ä¸ªæ€§åŒ–
```

#### å®ç°æ­¥éª¤

**Step 1: æ‰©å±• PasswordType å’Œ AuthenticationViewModel** (2å°æ—¶)

```swift
// File: ZeroNet-Space/ViewModels/AuthenticationViewModel.swift

/// å¯†ç ç±»å‹
enum PasswordType {
    case real      // çœŸå®å¯†ç  â†’ æ˜¾ç¤ºçœŸå®å†…å®¹
    case decoy     // ä¼ªè£…å¯†ç  â†’ æ˜¾ç¤ºä¼ªè£…å†…å®¹
    case invalid   // æ— æ•ˆå¯†ç 
}

class AuthenticationViewModel: ObservableObject {
    // ... ç°æœ‰ä»£ç  ...
    
    /// å½“å‰æ¨¡å¼ (æ–°å¢)
    @Published var currentMode: PasswordType = .real
    
    /// ç™»å½• (ä¿®æ”¹)
    func login() {
        guard !password.isEmpty else {
            errorMessage = "è¯·è¾“å…¥å¯†ç "
            return
        }
        
        isProcessing = true
        errorMessage = nil
        
        // å»¶è¿ŸéªŒè¯ (æ¨¡æ‹Ÿ)
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            // éªŒè¯å¯†ç 
            let passwordType = self.verifyPasswordType(self.password)
            
            switch passwordType {
            case .real:
                self.currentMode = .real
                self.sessionPassword = self.password
                self.isAuthenticated = true
                print("âœ… çœŸå®å¯†ç ç™»å½•æˆåŠŸ")
                
            case .decoy:
                self.currentMode = .decoy
                self.sessionPassword = self.password  // ä½¿ç”¨ä¼ªè£…å¯†ç 
                self.isAuthenticated = true
                print("âš ï¸ ä¼ªè£…å¯†ç ç™»å½• - æ˜¾ç¤ºä¼ªè£…å†…å®¹")
                
            case .invalid:
                self.errorMessage = "å¯†ç é”™è¯¯"
                self.isAuthenticated = false
            }
            
            self.password = ""
            self.isProcessing = false
        }
    }
    
    /// éªŒè¯å¯†ç ç±»å‹ (æ–°å¢)
    private func verifyPasswordType(_ password: String) -> PasswordType {
        // å…ˆéªŒè¯çœŸå®å¯†ç 
        if verifyPassword(password) {
            return .real
        }
        
        // å†éªŒè¯ä¼ªè£…å¯†ç 
        if verifyDecoyPassword(password) {
            return .decoy
        }
        
        return .invalid
    }
    
    /// éªŒè¯ä¼ªè£…å¯†ç  (æ–°å¢)
    private func verifyDecoyPassword(_ password: String) -> Bool {
        guard let storedDecoyHash = KeychainService.shared.getDecoyPasswordHash() else {
            return false
        }
        
        let salt = KeychainService.shared.getSalt() ?? Data()
        let inputHash = KeychainService.shared.hashPassword(password, salt: salt)
        
        return inputHash == storedDecoyHash
    }
}
```

**Step 2: æ‰©å±• KeychainService æ”¯æŒä¼ªè£…å¯†ç ** (1å°æ—¶)

```swift
// File: ZeroNet-Space/Services/KeychainService.swift

class KeychainService {
    // ... ç°æœ‰ä»£ç  ...
    
    private let decoyPasswordHashKey = "decoyPasswordHash"
    
    /// ä¿å­˜ä¼ªè£…å¯†ç å“ˆå¸Œ (æ–°å¢)
    func saveDecoyPasswordHash(_ password: String) -> Bool {
        guard !password.isEmpty else {
            print("âŒ ä¼ªè£…å¯†ç ä¸ºç©º")
            return false
        }
        
        let salt = getSalt() ?? Data()
        let hash = hashPassword(password, salt: salt)
        
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: decoyPasswordHashKey,
            kSecValueData as String: hash,
            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly
        ]
        
        // å…ˆåˆ é™¤æ—§æ•°æ®
        SecItemDelete(query as CFDictionary)
        
        // æ·»åŠ æ–°æ•°æ®
        let status = SecItemAdd(query as CFDictionary, nil)
        
        if status == errSecSuccess {
            print("âœ… ä¼ªè£…å¯†ç å“ˆå¸Œå·²ä¿å­˜åˆ°Keychain")
            return true
        } else {
            print("âŒ ä¿å­˜ä¼ªè£…å¯†ç å“ˆå¸Œå¤±è´¥: \(status)")
            return false
        }
    }
    
    /// è·å–ä¼ªè£…å¯†ç å“ˆå¸Œ (æ–°å¢)
    func getDecoyPasswordHash() -> Data? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: decoyPasswordHashKey,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        
        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)
        
        guard status == errSecSuccess, let data = result as? Data else {
            return nil
        }
        
        return data
    }
    
    /// åˆ é™¤ä¼ªè£…å¯†ç å“ˆå¸Œ (æ–°å¢)
    func deleteDecoyPasswordHash() -> Bool {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: decoyPasswordHashKey
        ]
        
        let status = SecItemDelete(query as CFDictionary)
        return status == errSecSuccess
    }
}
```

**Step 3: æ‰©å±• MediaItem æ”¯æŒä¼ªè£…æ ‡è®°** (30åˆ†é’Ÿ)

```swift
// File: ZeroNet-Space/Models/MediaItem.swift

@Model
final class MediaItem {
    // ... ç°æœ‰å±æ€§ ...
    
    /// æ˜¯å¦ä¸ºä¼ªè£…å†…å®¹ (æ–°å¢)
    var isDecoy: Bool = false
    
    init(
        fileName: String,
        fileExtension: String,
        fileSizeBytes: Int,
        mediaType: MediaType,
        encryptedPath: String,
        thumbnailData: Data? = nil,
        folder: Folder? = nil,
        tags: [Tag]? = nil,
        spaceType: SpaceType = .main,
        isDecoy: Bool = false  // æ–°å¢å‚æ•°
    ) {
        // ... ç°æœ‰åˆå§‹åŒ–ä»£ç  ...
        self.isDecoy = isDecoy  // æ–°å¢
    }
}
```

**Step 4: åˆ›å»ºä¼ªè£…æ¨¡å¼ç®¡ç†å™¨** (2å°æ—¶)

```swift
// File: ZeroNet-Space/Services/DecoyModeManager.swift

import SwiftUI
import Combine

/// ä¼ªè£…æ¨¡å¼ç®¡ç†å™¨
class DecoyModeManager: ObservableObject {
    
    // MARK: - Singleton
    
    static let shared = DecoyModeManager()
    private init() {
        loadSettings()
    }
    
    // MARK: - Published Properties
    
    /// æ˜¯å¦å¯ç”¨ä¼ªè£…æ¨¡å¼
    @Published var isEnabled: Bool = false {
        didSet {
            saveSettings()
        }
    }
    
    /// ä¼ªè£…å¯†ç æ˜¯å¦å·²è®¾ç½®
    @Published var isDecoyPasswordSet: Bool = false
    
    // MARK: - UserDefaults Keys
    
    private let defaults = UserDefaults.standard
    private let isEnabledKey = "decoyMode_isEnabled"
    
    // MARK: - Public Methods
    
    /// è®¾ç½®ä¼ªè£…å¯†ç 
    func setDecoyPassword(_ password: String) -> Bool {
        guard !password.isEmpty else { return false }
        
        let success = KeychainService.shared.saveDecoyPasswordHash(password)
        
        if success {
            isDecoyPasswordSet = true
            isEnabled = true
            
            print("âœ… ä¼ªè£…å¯†ç å·²è®¾ç½®")
        }
        
        return success
    }
    
    /// ç¦ç”¨ä¼ªè£…æ¨¡å¼
    func disable() {
        isEnabled = false
        isDecoyPasswordSet = false
        
        // åˆ é™¤ä¼ªè£…å¯†ç 
        _ = KeychainService.shared.deleteDecoyPasswordHash()
        
        print("ğŸ”“ ä¼ªè£…æ¨¡å¼å·²ç¦ç”¨")
    }
    
    /// æ£€æŸ¥æ˜¯å¦æœ‰ä¼ªè£…å†…å®¹
    func hasDecoyContent(in items: [MediaItem]) -> Bool {
        return items.contains { $0.isDecoy }
    }
    
    // MARK: - Private Methods
    
    private func loadSettings() {
        isEnabled = defaults.bool(forKey: isEnabledKey)
        
        // æ£€æŸ¥ä¼ªè£…å¯†ç æ˜¯å¦å­˜åœ¨
        isDecoyPasswordSet = KeychainService.shared.getDecoyPasswordHash() != nil
        
        print("ğŸ“– ä¼ªè£…æ¨¡å¼è®¾ç½®å·²åŠ è½½")
    }
    
    private func saveSettings() {
        defaults.set(isEnabled, forKey: isEnabledKey)
        
        print("ğŸ’¾ ä¼ªè£…æ¨¡å¼è®¾ç½®å·²ä¿å­˜")
    }
}
```

**Step 5: GalleryView è¿‡æ»¤ä¼ªè£…å†…å®¹** (1å°æ—¶)

```swift
// File: ZeroNet-Space/Views/Gallery/GalleryView.swift

struct GalleryView: View {
    @Environment(\.modelContext) private var modelContext
    @EnvironmentObject var authViewModel: AuthenticationViewModel
    @StateObject private var hiddenSpaceManager = HiddenSpaceManager.shared
    
    @Query private var allMediaItems: [MediaItem]
    
    var body: some View {
        NavigationStack {
            // ... ç°æœ‰å†…å®¹ ...
        }
    }
    
    // è¿‡æ»¤å½“å‰æ¨¡å¼çš„åª’ä½“é¡¹ (ä¿®æ”¹)
    private var mediaItems: [MediaItem] {
        let spaceFiltered = allMediaItems.filter { 
            $0.spaceType == hiddenSpaceManager.currentSpace 
        }
        
        // æ ¹æ®å½“å‰æ¨¡å¼è¿‡æ»¤
        switch authViewModel.currentMode {
        case .real:
            // çœŸå®æ¨¡å¼: æ˜¾ç¤ºéä¼ªè£…å†…å®¹
            return spaceFiltered.filter { !$0.isDecoy }
            
        case .decoy:
            // ä¼ªè£…æ¨¡å¼: æ˜¾ç¤ºä¼ªè£…å†…å®¹
            return spaceFiltered.filter { $0.isDecoy }
            
        case .invalid:
            return []
        }
    }
}
```

**Step 6: åˆ›å»ºä¼ªè£…å†…å®¹ç®¡ç†ç•Œé¢** (4å°æ—¶)

```swift
// File: ZeroNet-Space/Views/Settings/DecoyModeSettingsView.swift

import SwiftUI

struct DecoyModeSettingsView: View {
    @StateObject private var manager = DecoyModeManager.shared
    @State private var showPasswordSetup = false
    @State private var showDecoyContentManager = false
    @State private var showDisableConfirmation = false
    
    var body: some View {
        List {
            // çŠ¶æ€åŒºåŸŸ
            statusSection
            
            // å¯†ç è®¾ç½®
            if manager.isEnabled {
                passwordSection
            }
            
            // ä¼ªè£…å†…å®¹ç®¡ç†
            if manager.isEnabled {
                contentSection
            }
            
            // æ“ä½œåŒºåŸŸ
            actionsSection
        }
        .navigationTitle("ä¼ªè£…æ¨¡å¼")
        .navigationBarTitleDisplayMode(.inline)
        .sheet(isPresented: $showPasswordSetup) {
            DecoyPasswordSetupView()
        }
        .sheet(isPresented: $showDecoyContentManager) {
            DecoyContentManagerView()
        }
        .confirmationDialog("ç¦ç”¨ä¼ªè£…æ¨¡å¼", isPresented: $showDisableConfirmation) {
            Button("ç¦ç”¨", role: .destructive) {
                manager.disable()
            }
            Button("å–æ¶ˆ", role: .cancel) {}
        } message: {
            Text("ç¦ç”¨ä¼ªè£…æ¨¡å¼å,æ‰€æœ‰ä¼ªè£…å†…å®¹å°†è¢«åˆ é™¤")
        }
    }
    
    // MARK: - Status Section
    
    private var statusSection: some View {
        Section {
            HStack {
                Image(systemName: manager.isEnabled ? "theatermasks.fill" : "theatermasks")
                    .foregroundColor(manager.isEnabled ? .orange : .gray)
                    .font(.title2)
                
                VStack(alignment: .leading, spacing: 4) {
                    Text("ä¼ªè£…æ¨¡å¼")
                        .font(.headline)
                    Text(manager.isEnabled ? "å·²å¯ç”¨" : "æœªå¯ç”¨")
                        .font(.subheadline)
                        .foregroundColor(manager.isEnabled ? .orange : .secondary)
                }
                
                Spacer()
                
                if manager.isEnabled {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.green)
                        .font(.title3)
                }
            }
            
        } header: {
            Text("çŠ¶æ€")
        } footer: {
            Text("ä¼ªè£…æ¨¡å¼å…è®¸æ‚¨è®¾ç½®ä¸€ä¸ªä¼ªè£…å¯†ç ,è¾“å…¥æ—¶æ˜¾ç¤ºä¼ªè£…å†…å®¹è€ŒéçœŸå®å†…å®¹")
        }
    }
    
    // MARK: - Password Section
    
    private var passwordSection: some View {
        Section {
            HStack {
                Image(systemName: "key.fill")
                    .foregroundColor(.blue)
                    .frame(width: 24)
                
                VStack(alignment: .leading, spacing: 2) {
                    Text("ä¼ªè£…å¯†ç ")
                        .font(.subheadline)
                    Text(manager.isDecoyPasswordSet ? "å·²è®¾ç½®" : "æœªè®¾ç½®")
                        .font(.caption)
                        .foregroundColor(manager.isDecoyPasswordSet ? .green : .secondary)
                }
                
                Spacer()
                
                Button("ä¿®æ”¹") {
                    showPasswordSetup = true
                }
                .font(.subheadline)
            }
            
        } header: {
            Text("å¯†ç è®¾ç½®")
        } footer: {
            Text("ä¼ªè£…å¯†ç ä¸çœŸå®å¯†ç å¿…é¡»ä¸åŒ")
        }
    }
    
    // MARK: - Content Section
    
    private var contentSection: some View {
        Section {
            Button {
                showDecoyContentManager = true
            } label: {
                Label("ç®¡ç†ä¼ªè£…å†…å®¹", systemImage: "photo.stack")
                    .foregroundColor(.primary)
            }
            
        } header: {
            Text("ä¼ªè£…å†…å®¹")
        } footer: {
            Text("ä»ç›¸å†Œé€‰æ‹©å…¬å¼€ç…§ç‰‡ä½œä¸ºä¼ªè£…å†…å®¹")
        }
    }
    
    // MARK: - Actions Section
    
    private var actionsSection: some View {
        Section {
            if !manager.isEnabled {
                Button {
                    showPasswordSetup = true
                } label: {
                    Label("å¯ç”¨ä¼ªè£…æ¨¡å¼", systemImage: "plus.circle.fill")
                        .foregroundColor(.blue)
                }
            } else {
                Button(role: .destructive) {
                    showDisableConfirmation = true
                } label: {
                    Label("ç¦ç”¨ä¼ªè£…æ¨¡å¼", systemImage: "xmark.circle.fill")
                }
            }
        }
    }
}

// MARK: - Decoy Password Setup View

struct DecoyPasswordSetupView: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var manager = DecoyModeManager.shared
    @State private var password: String = ""
    @State private var confirmPassword: String = ""
    @State private var errorMessage: String?
    
    var body: some View {
        NavigationStack {
            Form {
                Section {
                    SecureField("ä¼ªè£…å¯†ç ", text: $password)
                    SecureField("ç¡®è®¤å¯†ç ", text: $confirmPassword)
                } header: {
                    Text("è®¾ç½®ä¼ªè£…å¯†ç ")
                } footer: {
                    if let error = errorMessage {
                        Text(error)
                            .foregroundColor(.red)
                    } else {
                        Text("ä¼ªè£…å¯†ç è‡³å°‘ 6 ä¸ªå­—ç¬¦,ä¸”ä¸èƒ½ä¸çœŸå®å¯†ç ç›¸åŒ")
                    }
                }
                
                Section {
                    Button("ä¿å­˜") {
                        savePassword()
                    }
                    .disabled(!isValid)
                }
            }
            .navigationTitle("ä¼ªè£…å¯†ç ")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("å–æ¶ˆ") {
                        dismiss()
                    }
                }
            }
        }
    }
    
    private var isValid: Bool {
        !password.isEmpty && password == confirmPassword && password.count >= 6
    }
    
    private func savePassword() {
        errorMessage = nil
        
        // éªŒè¯ä¸èƒ½ä¸çœŸå®å¯†ç ç›¸åŒ
        // (éœ€è¦æ¯”å¯¹,è¿™é‡Œç®€åŒ–å¤„ç†)
        
        let success = manager.setDecoyPassword(password)
        
        if success {
            dismiss()
        } else {
            errorMessage = "ä¿å­˜å¤±è´¥"
        }
    }
}

// MARK: - Decoy Content Manager View

struct DecoyContentManagerView: View {
    @Environment(\.dismiss) private var dismiss
    // å®ç°å¯¼å…¥ä¼ªè£…å†…å®¹çš„ç•Œé¢
    // (ç±»ä¼¼ ImportButtonsView,ä½†æ ‡è®°ä¸º isDecoy = true)
    
    var body: some View {
        NavigationStack {
            VStack {
                Text("ä¼ªè£…å†…å®¹ç®¡ç†")
                    .font(.title)
                
                Text("ä»ç›¸å†Œé€‰æ‹©å…¬å¼€ç…§ç‰‡ä½œä¸ºä¼ªè£…å†…å®¹")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding()
                
                // TODO: å®ç°ç…§ç‰‡é€‰æ‹©å™¨
                // é€‰ä¸­çš„ç…§ç‰‡æ ‡è®°ä¸º isDecoy = true
            }
            .navigationTitle("ä¼ªè£…å†…å®¹")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("å®Œæˆ") {
                        dismiss()
                    }
                }
            }
        }
    }
}

// MARK: - Preview

#Preview {
    NavigationStack {
        DecoyModeSettingsView()
    }
}
```

**Step 7: SettingsView æ·»åŠ å…¥å£** (15åˆ†é’Ÿ)

```swift
// File: ZeroNet-Space/Views/Settings/SettingsView.swift

private var securitySection: some View {
    Section {
        // éšè—ç©ºé—´
        NavigationLink {
            HiddenSpaceSettingsView()
        } label: {
            Label("éšè—ç©ºé—´", systemImage: "eye.slash.fill")
                .foregroundColor(.purple)
        }
        
        // æ–°å¢: ä¼ªè£…æ¨¡å¼
        NavigationLink {
            DecoyModeSettingsView()
        } label: {
            Label("ä¼ªè£…æ¨¡å¼", systemImage: "theatermasks.fill")
                .foregroundColor(.orange)
        }
        
        // ... ç°æœ‰å†…å®¹ ...
        
    } header: {
        Label("å®‰å…¨è®¾ç½®", systemImage: "lock.shield")
    }
}
```

**æµ‹è¯•æ¸…å•**:
- [ ] è®¾ç½®ä¼ªè£…å¯†ç æˆåŠŸ
- [ ] ä½¿ç”¨ä¼ªè£…å¯†ç ç™»å½•æ˜¾ç¤ºä¼ªè£…å†…å®¹
- [ ] ä½¿ç”¨çœŸå®å¯†ç ç™»å½•æ˜¾ç¤ºçœŸå®å†…å®¹
- [ ] çœŸå®å†…å®¹å’Œä¼ªè£…å†…å®¹å®Œå…¨éš”ç¦»
- [ ] ä¼ªè£…å†…å®¹ç®¡ç†åŠŸèƒ½æ­£å¸¸
- [ ] ç¦ç”¨ä¼ªè£…æ¨¡å¼åˆ é™¤ä¼ªè£…å†…å®¹

---

## Week 4: P2 ä¼˜åŒ–å’Œå®Œå–„

### ä»»åŠ¡ 4.1: æ‰¹é‡å¯¼å‡º â­ P2

**å·¥ä½œé‡**: 2-3 å¤©

**ç®€è¦è¯´æ˜**: å®ç°æ‰¹é‡å¯¼å‡ºåˆ°ç›¸å†Œå’ŒZIPå‹ç¼©åŒ…åŠŸèƒ½

### ä»»åŠ¡ 4.2: æ€§èƒ½ä¼˜åŒ– â­ P2

**å·¥ä½œé‡**: æŒç»­

**ä¼˜åŒ–é¡¹**:
1. å¤§æ–‡ä»¶åˆ†å—åŠ å¯†
2. ç¼©ç•¥å›¾æ‡’åŠ è½½ä¼˜åŒ–
3. å†…å­˜ç®¡ç†æ”¹è¿›
4. å¯¼å…¥è¿›åº¦æ˜¾ç¤º

---

## ğŸ“‹ æ€»ç»“

### å®ç°ä¼˜å…ˆçº§

| Week | åŠŸèƒ½ | ä¼˜å…ˆçº§ | çŠ¶æ€ |
|------|------|--------|------|
| 1 | æ·±è‰²æ¨¡å¼ + ç”Ÿç‰©è¯†åˆ« + ç½‘ç»œéªŒè¯ | P0 | å¾…å¼€å§‹ |
| 2 | éšè—ç©ºé—´ | P1 | å¾…å¼€å§‹ |
| 3-4 | ä¼ªè£…æ¨¡å¼ | P1 | å¾…å¼€å§‹ |
| 4 | æ‰¹é‡å¯¼å‡º + æ€§èƒ½ä¼˜åŒ– | P2 | å¾…å¼€å§‹ |

### é¢„æœŸæˆæœ

å®Œæˆå,é›¶ç½‘ç»œç©ºé—´ V1.2+ å°†æ‹¥æœ‰:

1. âœ… **å®Œæ•´çš„ V1.2 åŠŸèƒ½** - äº§å“å®šä½ä¹¦æ‰¿è¯ºçš„æ‰€æœ‰åŠŸèƒ½
2. âœ… **éšè—ç©ºé—´** - æ‰‹åŠ¿è¿›å…¥,ç‹¬ç«‹ä¿æŠ¤
3. âœ… **ä¼ªè£…æ¨¡å¼** - åŒå¯†ç ç³»ç»Ÿ,è¯¯å¯¼ä¿æŠ¤
4. âœ… **æ·±è‰²æ¨¡å¼** - ç‹¬ç«‹ä¸»é¢˜åˆ‡æ¢
5. âœ… **ç”Ÿç‰©è¯†åˆ«** - Face ID / Touch ID å¿«é€Ÿè§£é”
6. âœ… **ç½‘ç»œéªŒè¯** - æŠ€æœ¯è¯æ˜å®Œå…¨ç¦»çº¿

### ä¸‹ä¸€æ­¥

é€‰æ‹© Week 1 çš„ä»»åŠ¡å¼€å§‹å®ç°,å»ºè®®æŒ‰é¡ºåºæ‰§è¡Œä»¥ç¡®ä¿è´¨é‡ã€‚

---

**è®¡åˆ’åˆ¶å®šè€…**: Chief Architect + Implementation Planner  
**äº§å“ç‰ˆæœ¬**: é›¶ç½‘ç»œç©ºé—´ V1.2+  
**è®¡åˆ’æ—¥æœŸ**: 2025-11-15
